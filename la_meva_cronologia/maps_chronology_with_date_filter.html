<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Google Maps Chronology Visualizer</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    <!-- Flatpickr CSS for date range picker -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/flatpickr/4.6.13/flatpickr.min.css" />
    
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
        .header {
            background-color: #4285f4;
            color: white;
            padding: 1rem;
            text-align: center;
        }
        
        .content {
            display: flex;
            flex: 1;
        }
        
        .sidebar {
            width: 320px;
            padding: 1rem;
            background-color: #f1f1f1;
            overflow-y: auto;
        }
        
        #map {
            flex: 1;
            height: 100%;
        }
        
        .upload-container {
            margin-bottom: 1rem;
            padding: 1rem;
            border: 2px dashed #ccc;
            text-align: center;
            cursor: pointer;
        }
        
        .upload-container:hover {
            border-color: #4285f4;
            background-color: #e8f0fe;
        }
        
        .date-filter-container {
            margin-bottom: 1rem;
            padding: 1rem;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .date-filter-container h3 {
            margin-top: 0;
            color: #4285f4;
        }
        
        .date-input-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        
        .date-input-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .date-input-row label {
            min-width: 50px;
            font-size: 0.9rem;
            color: #666;
        }
        
        .date-input {
            flex: 1;
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.9rem;
        }
        
        .filter-buttons {
            display: flex;
            gap: 0.5rem;
        }
        
        .filter-btn {
            flex: 1;
            padding: 0.5rem;
            font-size: 0.8rem;
        }
        
        .filter-btn.clear {
            background-color: #f8f9fa;
            color: #666;
            border: 1px solid #ddd;
        }
        
        .filter-btn.clear:hover {
            background-color: #e9ecef;
        }
        
        .stats-container {
            margin-top: 1rem;
            border-top: 1px solid #ccc;
            padding-top: 1rem;
        }
        
        .legend {
            padding: 0.5rem;
            background-color: white;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            margin-top: 1rem;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        
        .legend-color {
            width: 20px;
            height: 10px;
            margin-right: 0.5rem;
        }
        
        button {
            background-color: #4285f4;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            cursor: pointer;
            border-radius: 4px;
            margin-top: 0.5rem;
        }
        
        button:hover {
            background-color: #3b78e7;
        }
        
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            display: none;
        }
        
        .spinner {
            border: 5px solid #f3f3f3;
            border-radius: 50%;
            border-top: 5px solid #4285f4;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }
        
        .filter-status {
            font-size: 0.8rem;
            color: #666;
            margin-top: 0.5rem;
            padding: 0.3rem;
            background-color: #e8f0fe;
            border-radius: 3px;
        }
        
        .quick-filters {
            display: flex;
            flex-wrap: wrap;
            gap: 0.3rem;
            margin-bottom: 0.5rem;
        }
        
        .quick-filter-btn {
            padding: 0.3rem 0.6rem;
            font-size: 0.8rem;
            background-color: #f8f9fa;
            color: #666;
            border: 1px solid #ddd;
            border-radius: 15px;
            cursor: pointer;
        }
        
        .quick-filter-btn:hover {
            background-color: #e9ecef;
        }
        
        .quick-filter-btn.active {
            background-color: #4285f4;
            color: white;
            border-color: #4285f4;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Google Maps Chronology Visualizer</h1>
        </div>
        
        <div class="content">
            <div class="sidebar">
                <div class="upload-container" id="uploadContainer">
                    <p>Drag & Drop your Google Maps JSON file here</p>
                    <p>Or</p>
                    <input type="file" id="fileInput" style="display: none;" accept=".json">
                    <button id="selectFileBtn">Select File</button>
                </div>
                
                <div class="date-filter-container" id="dateFilterContainer" style="display: none;">
                    <h3>ðŸ“… Date Filter</h3>
                    
                    <div class="quick-filters">
                        <button class="quick-filter-btn" data-days="7">Last 7 days</button>
                        <button class="quick-filter-btn" data-days="30">Last 30 days</button>
                        <button class="quick-filter-btn" data-days="90">Last 3 months</button>
                        <button class="quick-filter-btn" data-days="365">Last year</button>
                    </div>
                    
                    <div class="date-input-group">
                        <div class="date-input-row">
                            <label>From:</label>
                            <input type="text" id="startDate" class="date-input" placeholder="Select start date">
                        </div>
                        <div class="date-input-row">
                            <label>To:</label>
                            <input type="text" id="endDate" class="date-input" placeholder="Select end date">
                        </div>
                    </div>
                    
                    <div class="filter-buttons">
                        <button id="applyFilter" class="filter-btn">Apply Filter</button>
                        <button id="clearFilter" class="filter-btn clear">Clear Filter</button>
                    </div>
                    
                    <div id="filterStatus" class="filter-status" style="display: none;"></div>
                </div>
                
                <div class="controls">
                    <h3>Visualization Controls</h3>
                    <div>
                        <label for="segmentOpacity">Activity Path Opacity:</label>
                        <input type="range" id="segmentOpacity" min="0.1" max="1" step="0.1" value="0.6">
                    </div>
                    <div>
                        <label for="segmentWeight">Activity Path Thickness:</label>
                        <input type="range" id="segmentWeight" min="2" max="10" step="1" value="4">
                    </div>
                    <div>
                        <label for="pathOpacity">Timeline Path Opacity:</label>
                        <input type="range" id="pathOpacity" min="0.1" max="1" step="0.1" value="0.4">
                    </div>
                    <div>
                        <label for="pathWeight">Timeline Path Thickness:</label>
                        <input type="range" id="pathWeight" min="2" max="10" step="1" value="3">
                    </div>
                    <div>
                        <input type="checkbox" id="showActivities" checked>
                        <label for="showActivities">Show Activities</label>
                    </div>
                    <div>
                        <input type="checkbox" id="showVisits" checked>
                        <label for="showVisits">Show Visits</label>
                    </div>
                    <div>
                        <input type="checkbox" id="showTimelinePaths" checked>
                        <label for="showTimelinePaths">Show Timeline Paths</label>
                    </div>
                </div>
                
                <div class="stats-container">
                    <h3>Statistics</h3>
                    <div id="stats">
                        <p>Load a file to see statistics</p>
                    </div>
                </div>
                
                <div class="legend">
                    <h3>Legend</h3>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #4285f4;"></div>
                        <span>Activities (Walking)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #0f9d58;"></div>
                        <span>Activities (Vehicle)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #db4437;"></div>
                        <span>Activities (Unknown)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #9c27b0; border-radius: 50%;"></div>
                        <span>Visit Points</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #ff9800;"></div>
                        <span>Timeline Paths</span>
                    </div>
                </div>
            </div>
            
            <div id="map"></div>
        </div>
    </div>
    
    <div class="loading" id="loading">
        <div class="spinner"></div>
    </div>
    
    <!-- Leaflet JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
    <!-- Flatpickr JS for date range picker -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/flatpickr/4.6.13/flatpickr.min.js"></script>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize map
            const map = L.map('map').setView([0, 0], 2);
            
            // Add OpenStreetMap tile layer
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);
            
            // Layer groups for different data types
            const activitiesLayer = L.layerGroup().addTo(map);
            const visitsLayer = L.layerGroup().addTo(map);
            const timelinePathsLayer = L.layerGroup().addTo(map);
            
            // Data storage
            let originalData = null;
            let allActivities = [];
            let allVisits = [];
            let allTimelinePaths = [];
            let currentFilter = { startDate: null, endDate: null };
            
            // File handling
            const fileInput = document.getElementById('fileInput');
            const uploadContainer = document.getElementById('uploadContainer');
            const selectFileBtn = document.getElementById('selectFileBtn');
            const loading = document.getElementById('loading');
            const dateFilterContainer = document.getElementById('dateFilterContainer');
            
            // Date filter elements
            const startDateInput = document.getElementById('startDate');
            const endDateInput = document.getElementById('endDate');
            const applyFilterBtn = document.getElementById('applyFilter');
            const clearFilterBtn = document.getElementById('clearFilter');
            const filterStatus = document.getElementById('filterStatus');
            const quickFilterBtns = document.querySelectorAll('.quick-filter-btn');
            
            // Controls
            const segmentOpacity = document.getElementById('segmentOpacity');
            const segmentWeight = document.getElementById('segmentWeight');
            const pathOpacity = document.getElementById('pathOpacity');
            const pathWeight = document.getElementById('pathWeight');
            const showActivities = document.getElementById('showActivities');
            const showVisits = document.getElementById('showVisits');
            const showTimelinePaths = document.getElementById('showTimelinePaths');
            
            // Initialize Flatpickr date pickers
            const startPicker = flatpickr(startDateInput, {
                dateFormat: "Y-m-d",
                onChange: function(selectedDates, dateStr) {
                    // Update the "To" date picker's minDate
                    if (selectedDates[0]) {
                        endPicker.set('minDate', selectedDates[0]);
                    }
                }
            });
            
            const endPicker = flatpickr(endDateInput, {
                dateFormat: "Y-m-d",
                onChange: function(selectedDates, dateStr) {
                    // Update the "From" date picker's maxDate
                    if (selectedDates[0]) {
                        startPicker.set('maxDate', selectedDates[0]);
                    }
                }
            });
            
            // Quick filter buttons
            quickFilterBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    // Remove active class from all buttons
                    quickFilterBtns.forEach(b => b.classList.remove('active'));
                    // Add active class to clicked button
                    btn.classList.add('active');
                    
                    const days = parseInt(btn.dataset.days);
                    const endDate = new Date();
                    const startDate = new Date();
                    startDate.setDate(endDate.getDate() - days);
                    
                    startPicker.setDate(startDate);
                    endPicker.setDate(endDate);
                    
                    // Auto-apply the filter
                    applyDateFilter();
                });
            });
            
            // Filter control buttons
            applyFilterBtn.addEventListener('click', applyDateFilter);
            clearFilterBtn.addEventListener('click', clearDateFilter);
            
            // Handle drag and drop
            uploadContainer.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadContainer.style.borderColor = '#4285f4';
                uploadContainer.style.backgroundColor = '#e8f0fe';
            });
            
            uploadContainer.addEventListener('dragleave', (e) => {
                e.preventDefault();
                uploadContainer.style.borderColor = '#ccc';
                uploadContainer.style.backgroundColor = '';
            });
            
            uploadContainer.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadContainer.style.borderColor = '#ccc';
                uploadContainer.style.backgroundColor = '';
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            });
            
            selectFileBtn.addEventListener('click', () => {
                fileInput.click();
            });
            
            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    handleFile(e.target.files[0]);
                }
            });
            
            // Handle file processing
            function handleFile(file) {
                if (file.type !== 'application/json' && !file.name.endsWith('.json')) {
                    alert('Please select a JSON file');
                    return;
                }
                
                loading.style.display = 'flex';
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        originalData = data;
                        processData(data);
                        
                        // Show date filter controls after successful load
                        dateFilterContainer.style.display = 'block';
                        
                        // Initialize date range based on data
                        initializeDateRange();
                        
                    } catch (error) {
                        console.error('Error parsing JSON:', error);
                        alert('Error parsing JSON file. Please ensure it is a valid JSON format.');
                    } finally {
                        loading.style.display = 'none';
                    }
                };
                
                reader.onerror = () => {
                    alert('Error reading file');
                    loading.style.display = 'none';
                };
                
                reader.readAsText(file);
            }
            
            // Initialize date range from data
            function initializeDateRange() {
                if (!originalData || !originalData.semanticSegments) return;
                
                let minDate = null;
                let maxDate = null;
                
                originalData.semanticSegments.forEach(segment => {
                    if (segment.startTime) {
                        const start = new Date(segment.startTime);
                        if (!minDate || start < minDate) {
                            minDate = start;
                        }
                    }
                    
                    if (segment.endTime) {
                        const end = new Date(segment.endTime);
                        if (!maxDate || end > maxDate) {
                            maxDate = end;
                        }
                    }
                });
                
                if (minDate && maxDate) {
                    // Set the date picker bounds
                    startPicker.set('minDate', minDate);
                    startPicker.set('maxDate', maxDate);
                    endPicker.set('minDate', minDate);
                    endPicker.set('maxDate', maxDate);
                    
                    // Set default values to show all data
                    startPicker.setDate(minDate);
                    endPicker.setDate(maxDate);
                }
            }
            
            // Apply date filter
            function applyDateFilter() {
                const startDate = startPicker.selectedDates[0];
                const endDate = endPicker.selectedDates[0];
                
                if (!startDate || !endDate) {
                    alert('Please select both start and end dates');
                    return;
                }
                
                if (startDate > endDate) {
                    alert('Start date must be before end date');
                    return;
                }
                
                currentFilter.startDate = startDate;
                currentFilter.endDate = endDate;
                
                // Filter and re-render data
                if (originalData) {
                    const filteredData = filterDataByDateRange(originalData, startDate, endDate);
                    processData(filteredData);
                    
                    // Update filter status
                    const filteredCount = filteredData.semanticSegments.length;
                    const totalCount = originalData.semanticSegments.length;
                    filterStatus.textContent = `Showing ${filteredCount} of ${totalCount} segments (${formatDate(startDate)} - ${formatDate(endDate)})`;
                    filterStatus.style.display = 'block';
                }
            }
            
            // Clear date filter
            function clearDateFilter() {
                currentFilter.startDate = null;
                currentFilter.endDate = null;
                
                // Remove active class from quick filter buttons
                quickFilterBtns.forEach(btn => btn.classList.remove('active'));
                
                // Clear date inputs
                startPicker.clear();
                endPicker.clear();
                
                // Re-initialize date range
                initializeDateRange();
                
                // Show all data
                if (originalData) {
                    processData(originalData);
                    filterStatus.style.display = 'none';
                }
            }
            
            // Filter data by date range
            function filterDataByDateRange(data, startDate, endDate) {
                if (!data.semanticSegments) return data;
                
                const startTime = startDate.getTime();
                const endTime = endDate.getTime() + 24 * 60 * 60 * 1000 - 1; // End of day
                
                const filteredSegments = data.semanticSegments.filter(segment => {
                    // Check if segment overlaps with the date range
                    let segmentStart = null;
                    let segmentEnd = null;
                    
                    if (segment.startTime) {
                        segmentStart = new Date(segment.startTime).getTime();
                    }
                    
                    if (segment.endTime) {
                        segmentEnd = new Date(segment.endTime).getTime();
                    }
                    
                    // If we have both start and end times, check for overlap
                    if (segmentStart && segmentEnd) {
                        return segmentStart <= endTime && segmentEnd >= startTime;
                    }
                    
                    // If we only have start time, check if it's in range
                    if (segmentStart) {
                        return segmentStart >= startTime && segmentStart <= endTime;
                    }
                    
                    // If we only have end time, check if it's in range
                    if (segmentEnd) {
                        return segmentEnd >= startTime && segmentEnd <= endTime;
                    }
                    
                    // If no time information, include it
                    return true;
                });
                
                return {
                    ...data,
                    semanticSegments: filteredSegments
                };
            }
            
            // Process JSON data and visualize on map
            function processData(data) {
                // Clear previous data
                activitiesLayer.clearLayers();
                visitsLayer.clearLayers();
                timelinePathsLayer.clearLayers();
                
                if (!data.semanticSegments || !Array.isArray(data.semanticSegments)) {
                    alert('Invalid data format. Expected a JSON with semanticSegments array.');
                    return;
                }
                
                const bounds = L.latLngBounds();
                const activities = [];
                const visits = [];
                const timelinePaths = [];
                
                // Process each semantic segment
                data.semanticSegments.forEach(segment => {
                    if (segment.activity) {
                        // Process activity segments (movements)
                        processActivity(segment, bounds, activities);
                    } else if (segment.visit) {
                        // Process visit points
                        processVisit(segment, bounds, visits);
                    } else if (segment.timelinePath) {
                        // Process timeline paths
                        processTimelinePath(segment, bounds, timelinePaths);
                    }
                });
                
                // Store current data
                allActivities = activities;
                allVisits = visits;
                allTimelinePaths = timelinePaths;
                
                // Fit map to bounds
                if (!bounds.isValid()) {
                    map.setView([0, 0], 2);
                } else {
                    map.fitBounds(bounds);
                }
                
                // Update statistics
                updateStatistics(activities, visits, timelinePaths);
            }
            
            // Process activity segments
            function processActivity(segment, bounds, activities) {
                if (!segment.activity.start || !segment.activity.end) return;
                
                // Parse lat/lng strings from the format "41.524559Ã‚Â°, 2.1264009Ã‚Â°"
                const startLatLng = parseLatLng(segment.activity.start.latLng);
                const endLatLng = parseLatLng(segment.activity.end.latLng);
                
                if (!startLatLng || !endLatLng) return;
                
                // Determine color based on activity type
                let color = '#db4437'; // Red for unknown
                if (segment.activity.topCandidate) {
                    if (segment.activity.topCandidate.type === 'WALKING') {
                        color = '#4285f4'; // Blue for walking
                    } else if (segment.activity.topCandidate.type === 'IN_PASSENGER_VEHICLE') {
                        color = '#0f9d58'; // Green for vehicle
                    }
                }
                
                // Create polyline for activity
                const activityPath = L.polyline(
                    [
                        [startLatLng.lat, startLatLng.lng],
                        [endLatLng.lat, endLatLng.lng]
                    ],
                    {
                        color: color,
                        weight: parseInt(segmentWeight.value),
                        opacity: parseFloat(segmentOpacity.value)
                    }
                );
                
                // Add popup with details
                let popupContent = '<div><strong>Activity</strong><br>';
                if (segment.startTime && segment.endTime) {
                    popupContent += `Time: ${formatDate(segment.startTime)} - ${formatDate(segment.endTime)}<br>`;
                }
                if (segment.activity.distanceMeters) {
                    popupContent += `Distance: ${formatDistance(segment.activity.distanceMeters)}<br>`;
                }
                if (segment.activity.topCandidate && segment.activity.topCandidate.type) {
                    popupContent += `Type: ${formatActivityType(segment.activity.topCandidate.type)}<br>`;
                }
                popupContent += '</div>';
                
                activityPath.bindPopup(popupContent);
                activitiesLayer.addLayer(activityPath);
                
                bounds.extend([startLatLng.lat, startLatLng.lng]);
                bounds.extend([endLatLng.lat, endLatLng.lng]);
                
                activities.push({
                    startTime: segment.startTime,
                    endTime: segment.endTime,
                    type: segment.activity.topCandidate ? segment.activity.topCandidate.type : 'UNKNOWN',
                    distance: segment.activity.distanceMeters
                });
            }
            
            // Process visit points
            function processVisit(segment, bounds, visits) {
                if (!segment.visit || !segment.visit.topCandidate || !segment.visit.topCandidate.placeLocation) return;
                
                // Parse lat/lng string
                const latLng = parseLatLng(segment.visit.topCandidate.placeLocation.latLng);
                if (!latLng) return;
                
                // Create marker for visit point
                const marker = L.circleMarker([latLng.lat, latLng.lng], {
                    radius: 8,
                    fillColor: '#9c27b0', // Purple for visits
                    color: '#fff',
                    weight: 1,
                    opacity: 1,
                    fillOpacity: 0.8
                });
                
                // Add popup with details
                let popupContent = '<div><strong>Visit</strong><br>';
                if (segment.startTime && segment.endTime) {
                    popupContent += `Time: ${formatDate(segment.startTime)} - ${formatDate(segment.endTime)}<br>`;
                    popupContent += `Duration: ${calculateDuration(segment.startTime, segment.endTime)}<br>`;
                }
                if (segment.visit.topCandidate.placeId) {
                    popupContent += `Place ID: ${segment.visit.topCandidate.placeId}<br>`;
                }
                if (segment.visit.topCandidate.semanticType) {
                    popupContent += `Type: ${segment.visit.topCandidate.semanticType}<br>`;
                }
                if (segment.visit.probability) {
                    popupContent += `Probability: ${(segment.visit.probability * 100).toFixed(1)}%<br>`;
                }
                popupContent += '</div>';
                
                marker.bindPopup(popupContent);
                visitsLayer.addLayer(marker);
                
                bounds.extend([latLng.lat, latLng.lng]);
                
                visits.push({
                    startTime: segment.startTime,
                    endTime: segment.endTime,
                    placeId: segment.visit.topCandidate.placeId,
                    semanticType: segment.visit.topCandidate.semanticType,
                    probability: segment.visit.probability
                });
            }
            
            // Process timeline paths
            function processTimelinePath(segment, bounds, timelinePaths) {
                if (!segment.timelinePath || !Array.isArray(segment.timelinePath) || segment.timelinePath.length === 0) return;
                
                const points = [];
                const timelinePoints = [];
                
                // Process each point in the timeline path
                segment.timelinePath.forEach(point => {
                    const latLng = parseLatLng(point.point);
                    if (!latLng) return;
                    
                    points.push([latLng.lat, latLng.lng]);
                    bounds.extend([latLng.lat, latLng.lng]);
                    
                    timelinePoints.push({
                        lat: latLng.lat,
                        lng: latLng.lng,
                        time: point.time
                    });
                    
                    // Add small marker for each timeline point
                    const pointMarker = L.circleMarker([latLng.lat, latLng.lng], {
                        radius: 3,
                        fillColor: '#ff9800', // Orange for timeline points
                        color: '#fff',
                        weight: 1,
                        opacity: 1,
                        fillOpacity: 0.8
                    });
                    
                    pointMarker.bindPopup(`<strong>Timeline Point</strong><br>Time: ${formatDate(point.time)}`);
                    timelinePathsLayer.addLayer(pointMarker);
                });
                
                // Create polyline for timeline path if there are at least 2 points
                if (points.length >= 2) {
                    const pathLine = L.polyline(points, {
                        color: '#ff9800', // Orange for timeline paths
                        weight: parseInt(pathWeight.value),
                        opacity: parseFloat(pathOpacity.value),
                        dashArray: '5, 10' // Make it dashed to distinguish from activities
                    });
                    
                    // Add popup with details
                    let popupContent = '<div><strong>Timeline Path</strong><br>';
                    if (segment.startTime && segment.endTime) {
                        popupContent += `Time Range: ${formatDate(segment.startTime)} - ${formatDate(segment.endTime)}<br>`;
                    }
                    popupContent += `Points: ${points.length}<br>`;
                    popupContent += '</div>';
                    
                    pathLine.bindPopup(popupContent);
                    timelinePathsLayer.addLayer(pathLine);
                }
                
                timelinePaths.push({
                    startTime: segment.startTime,
                    endTime: segment.endTime,
                    points: timelinePoints
                });
            }
            
            // Helper function to parse lat/lng strings
            function parseLatLng(latLngStr) {
                if (!latLngStr) return null;
                
                // Format example: "41.524559Ã‚Â°, 2.1264009Ã‚Â°"
                const parts = latLngStr.split(',');
                if (parts.length !== 2) return null;
                
                const lat = parseFloat(parts[0].replace('Ã‚Â°', '').trim());
                const lng = parseFloat(parts[1].replace('Ã‚Â°', '').trim());
                
                if (isNaN(lat) || isNaN(lng)) return null;
                
                return { lat, lng };
            }
            
            // Format date for display
            function formatDate(dateStr) {
                if (!dateStr) return 'Unknown';
                
                try {
                    const date = new Date(dateStr);
                    return date.toLocaleString();
                } catch (e) {
                    return dateStr;
                }
            }
            
            // Calculate duration between two dates
            function calculateDuration(startStr, endStr) {
                if (!startStr || !endStr) return 'Unknown';
                
                try {
                    const start = new Date(startStr);
                    const end = new Date(endStr);
                    const diff = (end - start) / 1000; // in seconds
                    
                    if (diff < 60) {
                        return `${Math.round(diff)} seconds`;
                    } else if (diff < 3600) {
                        return `${Math.round(diff / 60)} minutes`;
                    } else if (diff < 86400) {
                        const hours = Math.floor(diff / 3600);
                        const minutes = Math.floor((diff % 3600) / 60);
                        return `${hours} hour${hours !== 1 ? 's' : ''} ${minutes} minute${minutes !== 1 ? 's' : ''}`;
                    } else {
                        const days = Math.floor(diff / 86400);
                        const hours = Math.floor((diff % 86400) / 3600);
                        return `${days} day${days !== 1 ? 's' : ''} ${hours} hour${hours !== 1 ? 's' : ''}`;
                    }
                } catch (e) {
                    return 'Error calculating duration';
                }
            }
            
            // Format distance for display
            function formatDistance(meters) {
                if (!meters) return 'Unknown';
                
                if (meters < 1000) {
                    return `${Math.round(meters)} meters`;
                } else {
                    return `${(meters / 1000).toFixed(2)} km`;
                }
            }
            
            // Format activity type for display
            function formatActivityType(type) {
                if (!type) return 'Unknown';
                
                // Replace underscores with spaces and capitalize each word
                return type.replace(/_/g, ' ').toLowerCase().replace(/(?:^|\s)\S/g, function(a) {
                    return a.toUpperCase();
                });
            }
            
            // Update statistics display
            function updateStatistics(activities, visits, timelinePaths) {
                const statsContainer = document.getElementById('stats');
                
                // Calculate statistics
                const totalActivities = activities.length;
                const totalVisits = visits.length;
                const totalPaths = timelinePaths.length;
                
                let totalDistance = 0;
                let activityTypes = {};
                
                activities.forEach(activity => {
                    if (activity.distance) {
                        totalDistance += activity.distance;
                    }
                    
                    if (activity.type) {
                        activityTypes[activity.type] = (activityTypes[activity.type] || 0) + 1;
                    }
                });
                
                // Calculate date range for current data
                let minDate = null;
                let maxDate = null;
                
                const allItems = [...activities, ...visits, ...timelinePaths];
                allItems.forEach(item => {
                    if (item.startTime) {
                        const start = new Date(item.startTime);
                        if (!minDate || start < minDate) {
                            minDate = start;
                        }
                    }
                    
                    if (item.endTime) {
                        const end = new Date(item.endTime);
                        if (!maxDate || end > maxDate) {
                            maxDate = end;
                        }
                    }
                });
                
                // Format HTML
                let statsHTML = '';
                
                if (minDate && maxDate) {
                    const daysDiff = Math.ceil((maxDate - minDate) / (1000 * 60 * 60 * 24));
                    statsHTML += `<p><strong>Date Range:</strong><br>${minDate.toLocaleDateString()} - ${maxDate.toLocaleDateString()}<br><small>(${daysDiff} days)</small></p>`;
                }
                
                statsHTML += `
                    <p><strong>Activities:</strong> ${totalActivities}</p>
                    <p><strong>Visits:</strong> ${totalVisits}</p>
                    <p><strong>Timeline Paths:</strong> ${totalPaths}</p>
                    <p><strong>Total Distance:</strong> ${formatDistance(totalDistance)}</p>
                `;
                
                if (Object.keys(activityTypes).length > 0) {
                    statsHTML += '<p><strong>Activity Types:</strong></p><ul>';
                    
                    Object.entries(activityTypes).forEach(([type, count]) => {
                        statsHTML += `<li>${formatActivityType(type)}: ${count}</li>`;
                    });
                    
                    statsHTML += '</ul>';
                }
                
                // Show filter information if active
                if (currentFilter.startDate && currentFilter.endDate) {
                    const totalSegments = originalData ? originalData.semanticSegments.length : 0;
                    const currentSegments = (totalActivities + totalVisits + totalPaths);
                    statsHTML += `<hr><p><strong>Filter Active:</strong><br>Showing ${currentSegments} of ${totalSegments} segments</p>`;
                }
                
                statsContainer.innerHTML = statsHTML;
            }
            
            // Control event listeners
            segmentOpacity.addEventListener('input', updateStyles);
            segmentWeight.addEventListener('input', updateStyles);
            pathOpacity.addEventListener('input', updateStyles);
            pathWeight.addEventListener('input', updateStyles);
            showActivities.addEventListener('change', updateVisibility);
            showVisits.addEventListener('change', updateVisibility);
            showTimelinePaths.addEventListener('change', updateVisibility);
            
            function updateStyles() {
                const segOpacity = parseFloat(segmentOpacity.value);
                const segWeight = parseInt(segmentWeight.value);
                const pOpacity = parseFloat(pathOpacity.value);
                const pWeight = parseInt(pathWeight.value);
                
                activitiesLayer.eachLayer(layer => {
                    if (layer instanceof L.Polyline) {
                        layer.setStyle({
                            opacity: segOpacity,
                            weight: segWeight
                        });
                    }
                });
                
                timelinePathsLayer.eachLayer(layer => {
                    if (layer instanceof L.Polyline) {
                        layer.setStyle({
                            opacity: pOpacity,
                            weight: pWeight
                        });
                    }
                });
            }
            
            function updateVisibility() {
                if (showActivities.checked) {
                    map.addLayer(activitiesLayer);
                } else {
                    map.removeLayer(activitiesLayer);
                }
                
                if (showVisits.checked) {
                    map.addLayer(visitsLayer);
                } else {
                    map.removeLayer(visitsLayer);
                }
                
                if (showTimelinePaths.checked) {
                    map.addLayer(timelinePathsLayer);
                } else {
                    map.removeLayer(timelinePathsLayer);
                }
            }
        });
    </script>
</body>
</html>
                