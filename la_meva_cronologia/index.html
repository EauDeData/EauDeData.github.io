<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Google Maps Chronology Visualizer</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
        .header {
            background-color: #4285f4;
            color: white;
            padding: 1rem;
            text-align: center;
        }
        
        .content {
            display: flex;
            flex: 1;
        }
        
        .sidebar {
            width: 300px;
            padding: 1rem;
            background-color: #f1f1f1;
            overflow-y: auto;
        }
        
        #map {
            flex: 1;
            height: 100%;
        }
        
        .upload-container {
            margin-bottom: 1rem;
            padding: 1rem;
            border: 2px dashed #ccc;
            text-align: center;
            cursor: pointer;
        }
        
        .upload-container:hover {
            border-color: #4285f4;
            background-color: #e8f0fe;
        }
        
        .stats-container {
            margin-top: 1rem;
            border-top: 1px solid #ccc;
            padding-top: 1rem;
        }
        
        .legend {
            padding: 0.5rem;
            background-color: white;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            margin-top: 1rem;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        
        .legend-color {
            width: 20px;
            height: 10px;
            margin-right: 0.5rem;
        }
        
        button {
            background-color: #4285f4;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            cursor: pointer;
            border-radius: 4px;
            margin-top: 0.5rem;
        }
        
        button:hover {
            background-color: #3b78e7;
        }
        
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            display: none;
        }
        
        .spinner {
            border: 5px solid #f3f3f3;
            border-radius: 50%;
            border-top: 5px solid #4285f4;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Google Maps Chronology Visualizer</h1>
        </div>
        
        <div class="content">
            <div class="sidebar">
                <div class="upload-container" id="uploadContainer">
                    <p>Drag & Drop your Google Maps JSON file here</p>
                    <p>Or</p>
                    <input type="file" id="fileInput" style="display: none;" accept=".json">
                    <button id="selectFileBtn">Select File</button>
                </div>
                
                <div class="controls">
                    <h3>Visualization Controls</h3>
                    <div>
                        <label for="segmentOpacity">Segment Opacity:</label>
                        <input type="range" id="segmentOpacity" min="0.1" max="1" step="0.1" value="0.5">
                    </div>
                    <div>
                        <label for="segmentWeight">Segment Thickness:</label>
                        <input type="range" id="segmentWeight" min="1" max="10" step="1" value="3">
                    </div>
                    <div>
                        <input type="checkbox" id="showPoints" checked>
                        <label for="showPoints">Show Points</label>
                    </div>
                    <div>
                        <input type="checkbox" id="showSegments" checked>
                        <label for="showSegments">Show Segments</label>
                    </div>
                </div>
                
                <div class="stats-container">
                    <h3>Statistics</h3>
                    <div id="stats">
                        <p>Load a file to see statistics</p>
                    </div>
                </div>
                
                <div class="legend">
                    <h3>Legend</h3>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: blue;"></div>
                        <span>Segments</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: red; border-radius: 50%;"></div>
                        <span>Visit Points</span>
                    </div>
                </div>
            </div>
            
            <div id="map"></div>
        </div>
    </div>
    
    <div class="loading" id="loading">
        <div class="spinner"></div>
    </div>
    
    <!-- Leaflet JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize map
            const map = L.map('map').setView([0, 0], 2);
            
            // Add OpenStreetMap tile layer
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);
            
            // Layer groups for segments and points
            const segmentsLayer = L.layerGroup().addTo(map);
            const pointsLayer = L.layerGroup().addTo(map);
            
            // File handling
            const fileInput = document.getElementById('fileInput');
            const uploadContainer = document.getElementById('uploadContainer');
            const selectFileBtn = document.getElementById('selectFileBtn');
            const loading = document.getElementById('loading');
            
            // Controls
            const segmentOpacity = document.getElementById('segmentOpacity');
            const segmentWeight = document.getElementById('segmentWeight');
            const showPoints = document.getElementById('showPoints');
            const showSegments = document.getElementById('showSegments');
            
            // Handle drag and drop
            uploadContainer.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadContainer.style.borderColor = '#4285f4';
                uploadContainer.style.backgroundColor = '#e8f0fe';
            });
            
            uploadContainer.addEventListener('dragleave', (e) => {
                e.preventDefault();
                uploadContainer.style.borderColor = '#ccc';
                uploadContainer.style.backgroundColor = '';
            });
            
            uploadContainer.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadContainer.style.borderColor = '#ccc';
                uploadContainer.style.backgroundColor = '';
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            });
            
            selectFileBtn.addEventListener('click', () => {
                fileInput.click();
            });
            
            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    handleFile(e.target.files[0]);
                }
            });
            
            // Handle file processing
            function handleFile(file) {
                if (file.type !== 'application/json' && !file.name.endsWith('.json')) {
                    alert('Please select a JSON file');
                    return;
                }
                
                loading.style.display = 'flex';
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        processData(data);
                    } catch (error) {
                        console.error('Error parsing JSON:', error);
                        alert('Error parsing JSON file. Please ensure it is a valid JSON format.');
                    } finally {
                        loading.style.display = 'none';
                    }
                };
                
                reader.onerror = () => {
                    alert('Error reading file');
                    loading.style.display = 'none';
                };
                
                reader.readAsText(file);
            }
            
            // Process JSON data and visualize on map
            function processData(data) {
                // Clear previous data
                segmentsLayer.clearLayers();
                pointsLayer.clearLayers();
                
                if (!Array.isArray(data)) {
                    alert('Invalid data format. Expected an array.');
                    return;
                }
                
                const bounds = L.latLngBounds();
                const segments = [];
                const points = [];
                
                // Process each item
                data.forEach(item => {
                    if (item.segment && item.segment.startLocation && item.segment.endLocation) {
                        // This is a segment
                        const startLat = item.segment.startLocation.latitudeE7 / 1e7;
                        const startLng = item.segment.startLocation.longitudeE7 / 1e7;
                        const endLat = item.segment.endLocation.latitudeE7 / 1e7;
                        const endLng = item.segment.endLocation.longitudeE7 / 1e7;
                        
                        // Create polyline for segment
                        const segmentPath = L.polyline(
                            [
                                [startLat, startLng],
                                [endLat, endLng]
                            ],
                            {
                                color: 'blue',
                                weight: parseInt(segmentWeight.value),
                                opacity: parseFloat(segmentOpacity.value)
                            }
                        );
                        
                        // Add popup with details
                        let popupContent = '<div><strong>Segment</strong><br>';
                        if (item.segment.duration) {
                            popupContent += `Duration: ${formatDuration(item.segment.duration)}<br>`;
                        }
                        if (item.segment.distance) {
                            popupContent += `Distance: ${formatDistance(item.segment.distance)}<br>`;
                        }
                        if (item.segment.activityType) {
                            popupContent += `Activity: ${item.segment.activityType}<br>`;
                        }
                        popupContent += '</div>';
                        
                        segmentPath.bindPopup(popupContent);
                        segmentsLayer.addLayer(segmentPath);
                        
                        bounds.extend([startLat, startLng]);
                        bounds.extend([endLat, endLng]);
                        
                        segments.push({
                            startLat,
                            startLng,
                            endLat,
                            endLng,
                            duration: item.segment.duration,
                            distance: item.segment.distance,
                            activityType: item.segment.activityType
                        });
                    } else if (item.location) {
                        // This is a point visit
                        const lat = item.location.latitudeE7 / 1e7;
                        const lng = item.location.longitudeE7 / 1e7;
                        
                        // Create marker for point
                        const marker = L.circleMarker([lat, lng], {
                            radius: 5,
                            fillColor: 'red',
                            color: '#fff',
                            weight: 1,
                            opacity: 1,
                            fillOpacity: 0.8
                        });
                        
                        // Add popup with details
                        let popupContent = '<div><strong>Visit</strong><br>';
                        if (item.duration) {
                            popupContent += `Duration: ${formatDuration(item.duration)}<br>`;
                        }
                        if (item.name) {
                            popupContent += `Name: ${item.name}<br>`;
                        }
                        if (item.address) {
                            popupContent += `Address: ${item.address}<br>`;
                        }
                        popupContent += '</div>';
                        
                        marker.bindPopup(popupContent);
                        pointsLayer.addLayer(marker);
                        
                        bounds.extend([lat, lng]);
                        
                        points.push({
                            lat,
                            lng,
                            duration: item.duration,
                            name: item.name,
                            address: item.address
                        });
                    }
                });
                
                // Fit map to bounds
                if (!bounds.isValid()) {
                    map.setView([0, 0], 2);
                } else {
                    map.fitBounds(bounds);
                }
                
                // Update statistics
                updateStatistics(segments, points);
            }
            
            // Format duration from timestamp
            function formatDuration(duration) {
                if (!duration || !duration.startTimestamp || !duration.endTimestamp) {
                    return 'Unknown';
                }
                
                const start = new Date(duration.startTimestamp);
                const end = new Date(duration.endTimestamp);
                const diff = (end - start) / 1000; // in seconds
                
                if (diff < 60) {
                    return `${Math.round(diff)} seconds`;
                } else if (diff < 3600) {
                    return `${Math.round(diff / 60)} minutes`;
                } else if (diff < 86400) {
                    const hours = Math.floor(diff / 3600);
                    const minutes = Math.floor((diff % 3600) / 60);
                    return `${hours} hour${hours !== 1 ? 's' : ''} ${minutes} minute${minutes !== 1 ? 's' : ''}`;
                } else {
                    const days = Math.floor(diff / 86400);
                    const hours = Math.floor((diff % 86400) / 3600);
                    return `${days} day${days !== 1 ? 's' : ''} ${hours} hour${hours !== 1 ? 's' : ''}`;
                }
            }
            
            // Format distance
            function formatDistance(distance) {
                if (!distance || !distance.value) return 'Unknown';
                
                const meters = distance.value;
                if (meters < 1000) {
                    return `${meters} meters`;
                } else {
                    return `${(meters / 1000).toFixed(2)} km`;
                }
            }
            
            // Update statistics display
            function updateStatistics(segments, points) {
                const statsContainer = document.getElementById('stats');
                
                // Calculate statistics
                const totalSegments = segments.length;
                const totalPoints = points.length;
                
                let totalDistance = 0;
                let activityTypes = {};
                
                segments.forEach(segment => {
                    if (segment.distance && segment.distance.value) {
                        totalDistance += segment.distance.value;
                    }
                    
                    if (segment.activityType) {
                        activityTypes[segment.activityType] = (activityTypes[segment.activityType] || 0) + 1;
                    }
                });
                
                // Format HTML
                let statsHTML = `
                    <p><strong>Total Segments:</strong> ${totalSegments}</p>
                    <p><strong>Total Visit Points:</strong> ${totalPoints}</p>
                    <p><strong>Total Distance:</strong> ${formatDistance({value: totalDistance})}</p>
                `;
                
                if (Object.keys(activityTypes).length > 0) {
                    statsHTML += '<p><strong>Activity Types:</strong></p><ul>';
                    
                    Object.entries(activityTypes).forEach(([type, count]) => {
                        statsHTML += `<li>${type}: ${count}</li>`;
                    });
                    
                    statsHTML += '</ul>';
                }
                
                statsContainer.innerHTML = statsHTML;
            }
            
            // Control event listeners
            segmentOpacity.addEventListener('input', updateStyles);
            segmentWeight.addEventListener('input', updateStyles);
            showPoints.addEventListener('change', updateVisibility);
            showSegments.addEventListener('change', updateVisibility);
            
            function updateStyles() {
                const opacity = parseFloat(segmentOpacity.value);
                const weight = parseInt(segmentWeight.value);
                
                segmentsLayer.eachLayer(layer => {
                    layer.setStyle({
                        opacity: opacity,
                        weight: weight
                    });
                });
            }
            
            function updateVisibility() {
                if (showPoints.checked) {
                    map.addLayer(pointsLayer);
                } else {
                    map.removeLayer(pointsLayer);
                }
                
                if (showSegments.checked) {
                    map.addLayer(segmentsLayer);
                } else {
                    map.removeLayer(segmentsLayer);
                }
            }
        });
    </script>
</body>
</html>